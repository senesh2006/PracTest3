import matplotlib.pyplot as plt
import numpy as np
import random
import argparse
from enum import Enum, auto

# Enums for state management
class BeeState(Enum):
    IN_HIVE = auto()
    SEEKING_NECTAR = auto()
    RETURNING = auto()

class BeeType(Enum):
    QUEEN = auto()
    WORKER = auto()
    DRONE = auto()

# Terrain constants
GRASS = 5
POND = 0
POND2 = 14
FLOWER = 12
DEPLETED_FLOWER = 13
TREE = 4
BUILDING = 8

# Configuration class
class SimulationConfig:
    def __init__(self):
        self.hive_size = (30, 25)
        self.world_size = (45, 40)
        self.hive_pos = (14, 20)
        self.max_steps = 100
        self.initial_bees = 15
        self.communication_range = 5
        self.nectar_capacity = 3

# World class with flower management
class World:
    def __init__(self, size):
        self.size = size
        self.grid = np.ones(size, dtype=int) * GRASS
        self.flowers = []
        self.depleted_flowers = []
        self.trees = []
        self.barriers = []
    
    def add_flower(self, pos):
        self.grid[pos[0], pos[1]] = FLOWER
        self.flowers.append(pos)
    
    def deplete_flower(self, pos):
        if pos in self.flowers:
            self.flowers.remove(pos)
            self.depleted_flowers.append(pos)
            self.grid[pos[0], pos[1]] = DEPLETED_FLOWER
    
    def add_tree(self, area):
        x1, x2, y1, y2 = area
        self.grid[x1:x2, y1:y2] = TREE
        self.trees.append(area)
    
    def add_barrier(self, area, barrier_type):
        x1, x2, y1, y2 = area
        self.grid[x1:x2, y1:y2] = barrier_type
        self.barriers.append((area, barrier_type))

# Hive class with nectar tracking
class Hive:
    def __init__(self, size, hive_pos):
        self.size = size
        self.hive_pos = hive_pos
        self.honey_stored = 0
        self.cells = np.ones(size) * 10  # Empty cells
        self.buildable_cells = [(14, 8), (14, 10), (14, 12),
                              (14, 14), (14, 16), (14, 18)]
        self.cell_nectar = {pos: 0 for pos in self.buildable_cells}
        
        for x, y in self.buildable_cells:
            self.cells[x, y] = 5  # Buildable placeholder
    
    def add_honey(self, amount):
        self.honey_stored += amount
        for pos in self.buildable_cells:
            if self.cell_nectar[pos] < 10:
                self.cell_nectar[pos] += amount
                if self.cell_nectar[pos] >= 10:
                    self.cells[pos[0], pos[1]] = 1  # Built cell
                break

# Enhanced Bee class with navigation
class Bee:
    def __init__(self, bee_id, pos, bee_type):
        self.id = bee_id
        self.pos = pos
        self.type = bee_type
        self.state = BeeState.IN_HIVE
        self.carrying_nectar = False
        self.nectar_locations = []
        self.current_mission_target = None
        self.steps_in_hive = 0
        
    def get_pos(self):
        return self.pos
    
    def is_in_hive(self):
        return self.state == BeeState.IN_HIVE
    
    def start_mission(self):
        if self.state == BeeState.IN_HIVE:
            self.state = BeeState.SEEKING_NECTAR
            self.steps_in_hive = 0
            return True
        return False
    
    def communicate_nectar_locations(self, other_bee):
        if self.state == BeeState.IN_HIVE and other_bee.state == BeeState.IN_HIVE:
            shared_locations = [loc for loc in self.nectar_locations 
                              if np.linalg.norm(np.array(loc) - np.array(self.pos)) <= config.communication_range]
            other_bee.nectar_locations.extend(shared_locations)
            other_bee.nectar_locations = list(set(other_bee.nectar_locations))
    
    def step_change(self, world, hive):
        if self.state == BeeState.IN_HIVE:
            self.steps_in_hive += 1
            if random.random() < 0.2 and self.steps_in_hive > 3:
                self.start_mission()
        
        elif self.state == BeeState.SEEKING_NECTAR:
            self.move_to_nectar(world)
            
        elif self.state == BeeState.RETURNING:
            self.return_to_hive(hive)
    
    def move_to_nectar(self, world):
        if self.current_mission_target:
            dx = np.sign(self.current_mission_target[0] - self.pos[0])
            dy = np.sign(self.current_mission_target[1] - self.pos[1])
        else:
            dx, dy = random.choice([(0,1),(1,0),(0,-1),(-1,0),(1,1),(-1,-1),(1,-1),(-1,1)])
        
        new_x = max(0, min(world.grid.shape[0]-1, self.pos[0] + dx))
        new_y = max(0, min(world.grid.shape[1]-1, self.pos[1] + dy))
        
        # Water collision detection
        if world.grid[new_x, new_y] in [POND, POND2]:
            self.state = BeeState.RETURNING
            self.current_mission_target = None
            return
        
        if world.grid[new_x, new_y] not in [BUILDING]:
            self.pos = (new_x, new_y)
            
            if world.grid[new_x, new_y] == FLOWER and not self.carrying_nectar:
                self.carrying_nectar = True
                self.nectar_locations.append((new_x, new_y))
                self.state = BeeState.RETURNING
                self.current_mission_target = None
                world.deplete_flower((new_x, new_y))
    
    def return_to_hive(self, hive):
        dx = np.sign(hive.hive_pos[0] - self.pos[0])
        dy = np.sign(hive.hive_pos[1] - self.pos[1])
        new_x = self.pos[0] + dx
        new_y = self.pos[1] + dy
        
        if (abs(new_x - hive.hive_pos[0]) <= 2 and 
            abs(new_y - hive.hive_pos[1]) <= 2):
            self.pos = hive.hive_pos
            self.deposit_nectar(hive)
            self.state = BeeState.IN_HIVE
            self.carrying_nectar = False
        else:
            self.pos = (
                max(0, min(world.grid.shape[0]-1, new_x)),
                max(0, min(world.grid.shape[1]-1, new_y))
            )
    
    def deposit_nectar(self, hive):
        if self.carrying_nectar:
            hive.add_honey(1)
            self.carrying_nectar = False

# Simulation setup
config = SimulationConfig()

def initialize_simulation():
    world = World(config.world_size)
    world.add_barrier((30, 40, 5, 10), POND)
    world.add_barrier((5, 10, 30, 35), POND2)
    
    for x in range(0, 10, 2):
        world.add_tree((x, x+1, 1, 4))
    
    for x in range(24, 45, 2):
        for y in range(20, 40, 2):
            world.add_flower((x, y))
    
    hive = Hive(config.hive_size, config.hive_pos)
    
    bees = []
    spawn_positions = [(random.randint(0, config.world_size[0]-1), 
                      random.randint(0, config.world_size[1]-1)) 
                     for _ in range(config.initial_bees)]
    
    roles = [BeeType.QUEEN] + \
            [BeeType.DRONE] * int(0.2 * (config.initial_bees-1)) + \
            [BeeType.WORKER] * (config.initial_bees - 1 - int(0.2 * (config.initial_bees-1)))
    
    for i, (pos, role) in enumerate(zip(spawn_positions, roles)):
        bees.append(Bee(f"{role.name[0]}{i+1}", pos, role))
    
    return world, hive, bees

def plot_hive(ax, hive, bees):
    ax.clear()
    hive_cmap = np.zeros((11, 4))
    hive_cmap[10] = [1, 1, 0.8, 1]    # Empty
    hive_cmap[5] = [0.9, 0.8, 0.5, 1] # Buildable
    for i in range(5):
        hive_cmap[i] = [0.6 + i*0.08, 0.4 + i*0.1, 0.1, 1]
    hive_cmap = plt.cm.colors.ListedColormap(hive_cmap)
    
    display_cells = hive.cells.copy()
    for pos, nectar in hive.cell_nectar.items():
        if nectar > 0 and nectar < 10:
            display_cells[pos[0], pos[1]] = 5 - (nectar // 2)
    
    ax.imshow(display_cells.T, origin="lower", cmap=hive_cmap, vmin=0, vmax=10)
    
    for bee in bees:
        if bee.is_in_hive():
            offset = (random.randint(-1,1), random.randint(-1,1))
            x = hive.hive_pos[0] + offset[0]
            y = hive.hive_pos[1] + offset[1]
            color = "red" if bee.type == BeeType.QUEEN else \
                   "blue" if bee.type == BeeType.DRONE else "yellow"
            ax.scatter(x, y, c=color, s=100, edgecolors='black')
    ax.set_title(f"Hive | Honey: {hive.honey_stored}")
    ax.set_xlabel("X")
    ax.set_ylabel("Y")

def plot_world(ax, world, bees):
    ax.clear()
    cmap = plt.cm.get_cmap('tab20', 20)
    colors = cmap(np.arange(20))
    colors[FLOWER] = [0, 1, 0, 1]
    colors[DEPLETED_FLOWER] = [0.5, 0.5, 0.5, 1]
    colors[TREE] = [0, 0.5, 0, 1]
    colors[GRASS] = [0.8, 1, 0.8, 1]
    colors[POND] = [0, 0, 1, 1]
    colors[POND2] = [0, 0, 0.8, 1]
    colors[BUILDING] = [0.3, 0.3, 0.3, 1]
    
    ax.imshow(world.grid.T, origin="lower", cmap=plt.cm.colors.ListedColormap(colors))
    
    for bee in bees:
        if not bee.is_in_hive():
            x, y = bee.get_pos()
            color = "red" if bee.type == BeeType.QUEEN else \
                   "blue" if bee.type == BeeType.DRONE else \
                   "orange" if bee.carrying_nectar else "yellow"
            ax.scatter(x, y, c=color, s=100, edgecolors='black')
    ax.set_title("World View")
    ax.set_xlabel("X")
    ax.set_ylabel("Y")

def run_simulation(world, hive, bees):
    plt.ion()
    fig, axes = plt.subplots(1, 2, figsize=(12, 6))
    
    for timestep in range(config.max_steps):
        for bee in bees:
            bee.step_change(world, hive)
            
            if bee.is_in_hive() and random.random() < 0.15:
                others = [b for b in bees if b != bee and b.is_in_hive()]
                if others:
                    bee.communicate_nectar_locations(random.choice(others))
        
        plot_hive(axes[0], hive, bees)
        plot_world(axes[1], world, bees)
        fig.suptitle(f"Timestep {timestep + 1}/{config.max_steps}", fontsize=14)
        plt.pause(0.1)
    
    plt.ioff()
    plt.show()

def parse_arguments():
    parser = argparse.ArgumentParser(description="Bee Simulation")
    parser.add_argument("-i", "--interactive", action="store_true", help="Interactive mode")
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_arguments()
    world, hive, bees = initialize_simulation()
    run_simulation(world, hive, bees)
