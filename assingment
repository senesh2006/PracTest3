import matplotlib.pyplot as plt
import numpy as np
import random
import argparse
from enum import Enum, auto
from matplotlib.patches import RegularPolygon

class BeeState(Enum):
    IN_HIVE = auto()
    SEEKING_NECTAR = auto()
    RETURNING = auto()

class BeeType(Enum):
    QUEEN = auto()
    WORKER = auto()
    DRONE = auto()

GRASS = 5
POND = 0
POND2 = 14
FLOWER = 12
DEPLETED_FLOWER = 13
TREE = 4
BUILDING = 8

class SimulationConfig:
    def __init__(self):
        self.world_size = (100, 80)
        self.hive_pos = (50, 40)
        self.max_steps = 150
        self.initial_bees = 25
        self.communication_range = 10
        self.nectar_capacity = 8

class World:
    def __init__(self, size):
        self.size = size
        self.grid = np.ones(size, dtype=int) * GRASS
        self.flowers = []
        self.depleted_flowers = []
        self.trees = []
        self.barriers = []

    def add_flower(self, pos):
        self.grid[pos[0], pos[1]] = FLOWER
        self.flowers.append(pos)

    def deplete_flower(self, pos):
        if pos in self.flowers:
            self.flowers.remove(pos)
            self.depleted_flowers.append(pos)
            self.grid[pos[0], pos[1]] = DEPLETED_FLOWER

    def add_tree(self, area):
        x1, x2, y1, y2 = area
        self.grid[x1:x2, y1:y2] = TREE
        self.trees.append(area)

    def add_barrier(self, area, barrier_type):
        x1, x2, y1, y2 = area
        self.grid[x1:x2, y1:y2] = barrier_type
        self.barriers.append((area, barrier_type))

class Hive:
    def __init__(self, hive_pos):
        self.hive_pos = hive_pos
        self.honey_stored = 0
        self.hexagons = []
        self.cell_nectar = {}

        hex_radius = 8
        vertical_spacing = hex_radius * np.sqrt(3)

        for side in [-1, 1]:
            for i in range(3):
                x = hive_pos[0] + side * hex_radius * 2
                y = hive_pos[1] + (i - 1) * vertical_spacing
                self.hexagons.append((x, y, hex_radius))
                self.cell_nectar[(x, y)] = 0

    def add_honey(self, amount):
        self.honey_stored += amount
        for pos in self.hexagons:
            if self.cell_nectar[pos] < 10:
                self.cell_nectar[pos] = min(10, self.cell_nectar[pos] + amount)
                break

class Bee:
    def __init__(self, bee_id, pos, bee_type):
        self.id = bee_id
        self.pos = pos
        self.type = bee_type
        self.state = BeeState.IN_HIVE
        self.carrying_nectar = False
        self.nectar_locations = []
        self.current_mission_target = None
        self.steps_in_hive = 0

    def get_pos(self):
        return self.pos

    def is_in_hive(self):
        return self.state == BeeState.IN_HIVE

    def start_mission(self):
        if self.state == BeeState.IN_HIVE:
            self.state = BeeState.SEEKING_NECTAR
            self.steps_in_hive = 0
            return True
        return False

    def communicate_nectar_locations(self, other_bee):
        if self.state == BeeState.IN_HIVE and other_bee.state == BeeState.IN_HIVE:
            shared_locations = [loc for loc in self.nectar_locations 
                              if np.linalg.norm(np.array(loc) - np.array(self.pos)) <= config.communication_range]
            other_bee.nectar_locations.extend(shared_locations)
            other_bee.nectar_locations = list(set(other_bee.nectar_locations))

    def step_change(self, world, hive):
        if self.state == BeeState.IN_HIVE:
            self.steps_in_hive += 1
            if random.random() < 0.3 and self.steps_in_hive > 2:
                self.start_mission()

        elif self.state == BeeState.SEEKING_NECTAR:
            self.move_to_nectar(world)

        elif self.state == BeeState.RETURNING:
            self.return_to_hive(hive)

    def move_to_nectar(self, world):
        if self.current_mission_target:
            dx = np.sign(self.current_mission_target[0] - self.pos[0])
            dy = np.sign(self.current_mission_target[1] - self.pos[1])
        else:
            dx, dy = random.choice([(0,1),(1,0),(0,-1),(-1,0),(1,1),(-1,-1),(1,-1),(-1,1)])

        new_x = int(max(0, min(world.grid.shape[0]-1, self.pos[0] + dx*2)))
        new_y = int(max(0, min(world.grid.shape[1]-1, self.pos[1] + dy*2)))

        if world.grid[new_x, new_y] in [POND, POND2]:
            self.state = BeeState.RETURNING
            self.current_mission_target = None
            return

        if world.grid[new_x, new_y] not in [BUILDING]:
            self.pos = (new_x, new_y)

            if world.grid[new_x, new_y] == FLOWER and not self.carrying_nectar:
                self.carrying_nectar = True
                self.nectar_locations.append((new_x, new_y))
                self.state = BeeState.RETURNING
                self.current_mission_target = None
                world.deplete_flower((new_x, new_y))

    def return_to_hive(self, hive):
        dx = np.sign(hive.hive_pos[0] - self.pos[0])
        dy = np.sign(hive.hive_pos[1] - self.pos[1])
        new_x = int(self.pos[0] + dx*3)
        new_y = int(self.pos[1] + dy*3)

        if np.linalg.norm(np.array([new_x, new_y]) - np.array(hive.hive_pos)) < 15:
            self.deposit_nectar(hive)
            self.state = BeeState.IN_HIVE
            self.carrying_nectar = False
        else:
            self.pos = (
                max(0, min(config.world_size[0]-1, new_x)),
                max(0, min(config.world_size[1]-1, new_y))
            )

    def deposit_nectar(self, hive):
        if self.carrying_nectar:
            hive.add_honey(3)
            self.carrying_nectar = False

config = SimulationConfig()

def initialize_simulation():
    world = World(config.world_size)
    world.add_barrier((35, 65, 15, 25), POND)
    world.add_barrier((10, 30, 55, 65), POND2)

    for x in range(60, 90, 2):
        for y in range(40, 70, 2):
            world.add_flower((x, y))

    for x in range(10, 30, 4):
        world.add_tree((x, x+3, 10, 20))

    hive = Hive(config.hive_pos)

    bees = []
    spawn_positions = [(random.randint(30, 70), random.randint(30, 50)) 
                     for _ in range(config.initial_bees)]

    roles = [BeeType.QUEEN] + \
            [BeeType.DRONE] * int(0.1 * (config.initial_bees-1)) + \
            [BeeType.WORKER] * (config.initial_bees - 1 - int(0.1 * (config.initial_bees-1)))

    for i, (pos, role) in enumerate(zip(spawn_positions, roles)):
        bees.append(Bee(f"{role.name[0]}{i+1}", pos, role))

    return world, hive, bees

def plot_hive(ax, hive, bees):
    ax.clear()
    ax.set_facecolor('#F5F5DC')

    for hex_data in hive.hexagons:
        x, y, radius = hex_data
        nectar = hive.cell_nectar[(x, y)]

        fill_color = (
            1.0 - 0.5*(nectar/10),
            1.0 - 0.7*(nectar/10),
            0.6 - 0.4*(nectar/10),
            1.0
        )

        hexagon = RegularPolygon(
            (x, y), 
            numVertices=6, 
            radius=radius,
            orientation=np.radians(30),
            facecolor=fill_color,
            edgecolor='#654321',
            linewidth=2
        )
        ax.add_patch(hexagon)

    for bee in bees:
        if bee.is_in_hive():
            angle = random.uniform(0, 2*np.pi)
            radius = random.uniform(0, 10)
            x = hive.hive_pos[0] + radius * np.cos(angle)
            y = hive.hive_pos[1] + radius * np.sin(angle)

            color = "#FF4500" if bee.type == BeeType.QUEEN else \
                    "#4169E1" if bee.type == BeeType.DRONE else "#FFD700"

            ax.scatter(x, y, c=color, s=150, edgecolors='black', zorder=10)

    ax.set_xlim(hive.hive_pos[0] - 40, hive.hive_pos[0] + 40)
    ax.set_ylim(hive.hive_pos[1] - 40, hive.hive_pos[1] + 40)
    ax.set_aspect('equal')
    ax.set_title(f"Honey Storage: {hive.honey_stored}", pad=20)
    ax.set_xticks([])
    ax.set_yticks([])

def plot_world(ax, world, bees):
    ax.clear()
    cmap = plt.cm.get_cmap('terrain')
    ax.imshow(world.grid.T, cmap=cmap, origin='lower')

    for bee in bees:
        if not bee.is_in_hive():
            color = "#FF4500" if bee.type == BeeType.QUEEN else \
                    "#4169E1" if bee.type == BeeType.DRONE else "#FFD700"
            ax.scatter(bee.pos[0], bee.pos[1], c=color, s=50, edgecolors='black')

    ax.set_xlim(0, world.size[0])
    ax.set_ylim(0, world.size[1])
    ax.set_title("Bee Simulation World")
    ax.set_xticks([])
    ax.set_yticks([])

def run_simulation(world, hive, bees):
    plt.ion()
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18, 8))
    plt.subplots_adjust(wspace=0.25)

    for timestep in range(config.max_steps):
        for bee in bees:
            bee.step_change(world, hive)

            if bee.is_in_hive() and random.random() < 0.2:
                others = [b for b in bees if b != bee and b.is_in_hive()]
                if others:
                    bee.communicate_nectar_locations(random.choice(others))

        plot_hive(ax1, hive, bees)
        plot_world(ax2, world, bees)
        fig.suptitle(f"Bee Colony Simulation - Timestep {timestep + 1}/{config.max_steps}", fontsize=16, y=0.97)
        plt.pause(0.08)

    plt.ioff()
    plt.show()

def parse_arguments():
    parser = argparse.ArgumentParser(description="Enhanced Bee Simulation")
    parser.add_argument("-i", "--interactive", action="store_true", help="Enable interactive visualization mode")
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_arguments()
    world, hive, bees = initialize_simulation()
    run_simulation(world, hive, bees)



